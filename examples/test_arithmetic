#!/usr/bin/env ruby
require 'colorize'
require 'neuronet'

MANY = 100_000

def network(i)
  ffn, type = nil, nil
  case i
  when 1
    ffn = Neuronet::FeedForward.new([2,1])
    type = '[2,1]'
  when 2
    ffn = Neuronet::FeedForward.new([2,4,1])
    type = '[2,4,1]'
  when 3
    ffn = Neuronet::FeedForward.new([2,4,1])
    Neuronet::Tao.bless ffn
    type = '[2,4,1].Tao'
  when 4
    ffn = Neuronet::FeedForward.new([2,4,1])
    Neuronet::Brahma.bless ffn
    type = '[2,4,1].Brahma'
  when 5
    ffn = Neuronet::FeedForward.new([2,4,1])
    Neuronet::Tao.bless Neuronet::Brahma.bless ffn
    type = '[2,4,1].TaoBrahma'
  when 6
    ffn = Neuronet::FeedForward.new([2,4,8,1])
    Neuronet::Brahma.bless Neuronet::Vishnu.bless ffn
    type = '[2,4,8,1].BrahmaVishnu'
  end
  [ffn, type]
end

[
  ['Add',proc{|a,b|a+b}],
  ['Subtract',proc{|a,b|a-b}],
  ['Multiply',proc{|a,b|a*b}],
].each do |name, f|
  1.upto(6) do |i|
    ffn, type = network(i)
    MANY.times do
      input = [rand-rand, rand-rand] # creates [(-1,1), (-1,1)]
      target = [f.call(input[0], input[1])]
      ffn.pair(input, target)
    end
    sum = 0.0
    10_000.times do
      input = [rand-rand, rand-rand]
      target = f.call(input[0], input[1])
      ffn.set(input).update
      output = ffn.output.first
      error = target - output
      sum += error*error
    end
    std = Math.sqrt(sum/10_000.to_f)
    color = std < 0.015 ? :green : :red
    puts "#{std.round(4)}, #{name}, #{type}".colorize(color)
  end
end
puts <<~MSG
  I've yet to observe any of the provided architectures do multiplication.
  If you figure out an network architecture that can do multiplication,
  email me a description of it at carlosjhr64@gmail.com.
MSG
